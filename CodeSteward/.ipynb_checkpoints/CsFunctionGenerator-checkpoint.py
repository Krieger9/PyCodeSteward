from typing import List, Optional, Tuple

from pydantic.v1 import BaseModel, Field
from enum import Enum

from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.prompts import PromptTemplate
from langchain_core.runnables import RunnableParallel, RunnablePassthrough
from langchain.output_parsers import PydanticOutputParser


def sanitize_text(text: str):
    return text.replace("{", "{{").replace("}", "}}")

class CSharpBaseTypes(str, Enum):
    INT = 'int'
    STRING = 'string'
    FLOAT = 'float'
    DOUBLE = 'double'
    BOOL = 'bool'
    CHAR = 'char'
    DECIMAL = 'decimal'
    OBJECT = 'object'

class FunctionParameter(BaseModel):
    Name: Optional[str] = Field(None, description="parameter name.  Used to indicate it's context for the value provided.  If not provided, can be autogenerated if a good name can be determined.")
    Type: Optional[CSharpBaseTypes] = Field(None, description="the C# type for this parameter")
    Description: Optional[str] = Field(None, description="Longer context of the purpose of the variable and how the provided value of it is to be used in the function context")

class FunctionRequirements(BaseModel):
    FunctionDefinition: Optional[str] = Field(None, description="The purpose of the function.  What it is intended to do, how it uses the parameters and what operations would be needed to produce the return value.  Also any constraints, errors to check for and exceptions that may be needed to be thrown.")
    ReturnType: Optional[CSharpBaseTypes] = Field(None, description="The type to be used for the return result calculated as specified in the above 'FunctionDefinition'.")
    Parameters: Optional[List[FunctionParameter]] = Field(None, description="Parameters to provide the method.  These should specify everything needed to perform the operation as specified in the above 'FunctionDefinition'.")

class FunctionExtractionResponse(BaseModel):
    Requirements: FunctionRequirements = Field(description="The requirements gathered so far for defining the function we will eventually want written by a C# more junior developer")
    MissingContext: Optional[str] = Field(None, description="The information needed to be gathered yet from the Product Owner or Stakeholder to properly define a function before coding it.")
    IsComplete:str = Field(description="After analyzing was True if it was determined the function criteria and definition is complete enough to forward to the next developer for coding or False if missing details are being requested")

class DefinitionStatus(str, Enum):
    UNDEFINED = 'undefined'
    PARTIALLY_DEFINED = 'partially defined'
    DEFINED = 'defined'

class IsFunctionDefinitionCompleteResponse(BaseModel):
    RequestedClarifications: Optional[List[str]] = None
    Status: DefinitionStatus = Field(description="'UNDEFINED' when there are too many questions to take a quality guess at.  'PARTIALLY_DEFINED' when there are missing details, but intelligent suggestions can be made.  'DEFINED' when we have reached a high quality defitinion for our function.")

CSharpEngineer_identity = """You are a Brilliant C# Engineer / Architect.  You are a master of Hexoganal code, SOLID and best practices.  
You are adept at understanding complex requirements and asking precise questions to clarify them.
You so you frequently ask for clarifications and always gather detailed requirements before you attempt to write code, but will often provide an example with guess or suggestion.
You focus on breaking down tasks into organized concepts to create methodically organized structure."""

gather_requirements_template = """You are given a task to write a C# function by your Stakeholder.  The instructions simply read: {message}.  
Would you attempt to write this function from the provided context or ask for clarifications from the product owner?  Please provide only the response json."""

class CsFunctionGenerator:
    def __init__(self):
        self.history = [("system", CSharpEngineer_identity), ("user", gather_requirements_template)]        
        self.function_requirements = FunctionRequirements()
        
    def ExtractFunctionRequirements(self, text_message:str):
        self.history.append(("user", text_message))
        
        model = ChatOpenAI(model="gpt-4")
        requirements_parser = PydanticOutputParser(pydantic_object=IsFunctionDefinitionCompleteResponse)
        conversation = self.history + [("system", sanitize_text(requirements_parser.get_format_instructions()))]
        prompt = ChatPromptTemplate.from_messages(conversation) 

        chain = (
            {"message":RunnablePassthrough()}
            | prompt
            | model
            | requirements_parser
        )
        result = chain.invoke({"message":text_message})
        
        if(result.Status!=DefinitionStatus.DEFINED):
            clarifications = [("assistant",clarification) for clarification in result.RequestedClarifications]
            self.history.extend(clarifications)

        return result
